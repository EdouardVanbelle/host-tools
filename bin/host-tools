#!/bin/bash

# --------------------------- default config

# setup it into /etc/host-tools.conf

DISKLIMIT=75
BADSECTORLIMIT=0
ALLOW_ROOT_PASWORD="NO"
MANDATORY_SERVICES=("ssh.service")
MANDATORY_DOCKERS=()
MANDATORY_FILES=()
MANDATORY_PACKAGES=("openssh-server")
FORBIDDEN_PACKAGES=()
ROOT_KEYS=()
WEBHOOK=""

# ----------------------------------------


CONFIG="/etc/host-tools.conf"
REPORT="/var/run/host-tools.report"
LOCK="/var/run/host-tools.lock"
HOSTNAME=$(hostname)
SCRIPTNAME=$(basename $0)

ALARM=0
CONFIG_LOADED=0
COMMAND_FOUND=0
NOTIFY=1

# keep original language to normalize script output
LANG=C

# ---------------------------------------- helpers

urlencode() {
    # urlencode <string>
    local old_lc_collate=$LC_COLLATE
    LC_COLLATE="C"
    
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *)               printf '%%%02X' "'$c" ;;
        esac
    done
    
    LC_COLLATE=$old_lc_collate
}

alert() {
	ALARM=1
	logger -s -p user.crit -t "$SCRIPTNAME" -- "$@"
	echo "$@" >>$REPORT
}

notify() {

	if [ $NOTIFY -eq 0 ]
	then
		echo "Silent mode do not notify: $*"
		return
	fi

	local message=$( urlencode "$*")

	if [ -z "$WEBHOOK" ] 
	then
		alert "WEBHOOK not defined, cannot notify"
		return
	fi

	curl -s -q "${WEBHOOK}${message}" >/dev/null
}

load_config() {

	if ! [ -e $CONFIG ]
	then
		echo "configuration $CONFIG not found"
		return 1
	fi

	echo testing

	if [ "$(stat -c '%u %g' -L $CONFIG)" != "0 0" ]
	then
		echo "SECURITY: $CONFIG must be owner by uid: root group: root" 
		exit 1
	fi

	#expected return: -rw-r--r-- 
	if echo "$(stat -c '%A' -L $CONFIG)" | grep -q '^........w.$'
	then
		echo "SECURITY: $CONFIG cannot be writable by anybody"
		exit 1
	fi

	# load config (XXX: dangerous , can execute arbitrary command)
	source $CONFIG

	CONFIG_LOADED=1
}

end() {
	rm -f $LOCK
}


# ---------------------------------------- checks

check_root_sshkeys() {

	local AUTHORIZED_KEY="/root/.ssh/authorized_keys2"

        local PREV_IFS=$IFS
	IFS="" 
	for KEY in ${ROOT_KEYS[@]}
	do
		local SHORTKEY=$(echo "$KEY" | awk '{ print $1 " ... " $NF }')
		echo "ensure that $SHORTKEY is present for root"
		if ! ( grep -q ^$KEY $AUTHORIZED_KEY )
		then
			alert "$SHORTKEY is missing in $AUTHORIZED_KEY"
		fi
	done
	IFS=$PREV_IFS
}

check_no_root_password() {
	# because I prefer keys

	[ "$ALLOW_ROOT_PASWORD" == "yes"  ] && echo "allow root password" && return
	[ "$ALLOW_ROOT_PASWORD" == "YES"  ] && echo "allow root password" && return
	[ "$ALLOW_ROOT_PASWORD" == "true" ] && echo "allow root password" && return
	[ "$ALLOW_ROOT_PASWORD" == "TRUE" ] && echo "allow root password" && return

	echo "checking no root password"

	local ROOT_PASS=$(getent shadow root | cut -d : -f 2)
	[ "$ROOT_PASS" != "*" ] && alert "this machine has a root password, please use ssh key"
}

check_security_upgrade() {

	echo checking security package to upgrade

        if ! which apt-get >/dev/null
        then
               echo "apt-get not found, I only know debian systems [ignoring test]"
               return
        fi


	apt-get update >/tmp/security-update.list 2>&1
	if grep -q '^[WE]:' /tmp/security-update.list 
	then
		alarm "got warning in apt-get update"
		cat /tmp/security-update.list
	fi

	apt-get upgrade -s >/tmp/security-upgrade.list 2>&1
	if grep -i security /tmp/security-upgrade.list 
	then
		grep -i security /tmp/security-upgrade.list
		alert "system has security packages to upgrade"
	fi

	apt-get clean >/dev/null 2>/dev/null
	#apt-get auto-clean

	rm -f /tmp/security-upgrade.list
	rm -f /tmp/security-update.list
}

check_packages() {

	# FIXME should support alpine with apk
	if ! which dpkg >/dev/null
	then
		echo "dpkg not found, I only know debian distribution [ignoring test]"
		return
	fi

	# check that package are fully installed
	dpkg --audit > /tmp/host-tools.package-audit

	if [ $(wc -l </tmp/host-tools.package-audit) -gt 0 ]
	then
		alert "found partial or unconfigured packages during dpkg audit"
		cat /tmp/host-tools.packages-audit
	fi

	rm -f /tmp/host-tools.package-audit

	if [ ${#MANDATORY_PACKAGES[@]} == 0 ]
        then
               echo "no mandatory package in config"
               return
        fi

	dpkg --get-selections > /tmp/host-tools.package-list

	for PACKAGE in ${MANDATORY_PACKAGES[@]}
	do
		if grep -q "^$PACKAGE\s\+install$" /tmp/host-tools.package-list 
		then
			echo "mandatory package $PACKAGE is installed"
		else
			alert "mandatory package $PACKAGE is missing"
		fi
	done

	for PACKAGE in ${FORBIDDEN_PACKAGES[@]}
	do
		if grep -q "^$PACKAGE\s\+install$" /tmp/host-tools.package-list 
		then
			alert "forbidden package $PACKAGE must be removed/purged"
		fi
	done

	rm -f /tmp/host-tools.package-list
	
}

check_services() {

	echo "checking systemd services status"

        if ! which systemctl >/dev/null
        then
               echo "systemctl not found (system is not running using systemd ?) [ignoring test]"
               return
        fi

	# example of output
	# networking.service loaded    failed failed Raise network interfaces
	# ureadahead.service not-found failed failed ureadahead.service
	while read -r SERVICE LOAD ACTIVE RUN DESCRIPTION
	do
		alert "service $SERVICE warning (loaded=$LOAD active=$ACTIVE run=$RUN)"

	done < <( systemctl --state=failed  --no-pager --no-legend list-units )

	for SERVICE in ${MANDATORY_SERVICES[@]}
	do
		systemctl --no-pager --no-legend list-units "$SERVICE" | { read -r _S LOAD ACTIVE RUN DESCRIPTION
			if [ "$_S" == "" ]
			then
				alert "mandatory service $SERVICE not running (not found)"
			elif [ "$RUN" != "running" ]
			then
				alert "mandatory service $SERVICE not running (loaded=$LOAD active=$ACTIVE run=$RUN)"
			else
				echo "mandatory service $SERVICE is running"
			fi
		}
	done
}

check_disk_sectors() {

        if ! which smartctl >/dev/null
        then
               echo "smartctl not installed (fix: apt-get install smartmontools) [ignoring test]"
               return
        fi

        if which lshw >/dev/null
        then
               # disk list
               DISKS=$(lshw -class disk -short -quiet | tail -n +3 | awk '{ print $2; }')
        else
               echo "lshw not installed get disk list via /dev/disk (better via: apt-get install lshw)"
               DISKS=$(readlink -f /dev/disk/by-id/* | grep -e '[a-z]$' | sort | uniq )
        fi

	# foreach disk
        for DISK in $( echo $DISKS)
	do

		echo "checking disk $DISK"

		# foreach smartctl

		# smartctl 6.6 2017-11-05 r4594 [x86_64-linux-4.19.0-8-amd64] (local build)
		# Copyright (C) 2002-17, Bruce Allen, Christian Franke, www.smartmontools.org
		#
		# === START OF READ SMART DATA SECTION ===
		# SMART Attributes Data Structure revision number: 16
		# Vendor Specific SMART Attributes with Thresholds:
		# ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE
		#   1 Raw_Read_Error_Rate     0x000b   100   100   016    Pre-fail  Always       -       0
		#   2 Throughput_Performance  0x0005   136   136   054    Pre-fail  Offline      -       80
		#   3 Spin_Up_Time            0x0007   193   193   024    Pre-fail  Always       -       248 (Average 399)
		#   4 Start_Stop_Count        0x0012   100   100   000    Old_age   Always       -       16
		#   5 Reallocated_Sector_Ct   0x0033   100   100   005    Pre-fail  Always       -       0
		#   7 Seek_Error_Rate         0x000b   100   100   067    Pre-fail  Always       -       0
		#   8 Seek_Time_Performance   0x0005   145   145   020    Pre-fail  Offline      -       24
		#   9 Power_On_Hours          0x0012   095   095   000    Old_age   Always       -       39172
		#  10 Spin_Retry_Count        0x0013   100   100   060    Pre-fail  Always       -       0
		#  12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       16
		# 192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       16
		# 193 Load_Cycle_Count        0x0012   100   100   000    Old_age   Always       -       16
		# 194 Temperature_Celsius     0x0002   166   166   000    Old_age   Always       -       36 (Min/Max 18/49)
		# 196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0
		# 197 Current_Pending_Sector  0x0022   100   100   000    Old_age   Always       -       0
		# 198 Offline_Uncorrectable   0x0008   100   100   000    Old_age   Offline      -       0
		# 199 UDMA_CRC_Error_Count    0x000a   200   200   000    Old_age   Always       -       0

		while read -r ID ATTRIBUTE_NAME FLAG VALUE WORST THRESH TYPE UPDATED WHEN_FAILED RAW_VALUE
		do
			[ -z "$ATTRIBUTE_NAME" ] && continue
			[ -z "$RAW_VALUE" ] && continue

			# debug echo "$DISK $ATTRIBUTE_NAME $RAW_VALUE" 

			case "$ATTRIBUTE_NAME" in 
				"Reallocated_Sector_Ct")
					[ $RAW_VALUE -gt $BADSECTORLIMIT ] && alert "$DISK has $RAW_VALUE bad sectors";
					;;
				"Current_Pending_Sector")
					[ $RAW_VALUE -gt $BADSECTORLIMIT ] && alert "$DISK has $RAW_VALUE coming bad sectors";
					;;
			esac

		done < <( smartctl -A $DISK 2>/dev/null )
	done
}

check_partition_space() {

	while read -r PARTITION FSTYPE IPCENT PCENT
	do
		IPCENT=${IPCENT%?}
		PCENT=${PCENT%?}

		echo checking partition $PARTITION

		if [ $PCENT -ge $DISKLIMIT ]
		then
			alert "$PARTITION reached size limit: $PCENT %"
		fi

		[ -z "$IPCENT" ] && continue


		if [ $IPCENT -ge $DISKLIMIT ]
		then
			alert "$PARTITION reached inode size limit: $IPCENT %"
		fi

	done < <( df -l --exclude-type="devtmpfs" --exclude-type="tmpfs" --output="source,fstype,ipcent,pcent" | tail -n +2 )
}

check_partition_writable() {
	# FIXME: must do it
	true
}

check_docker() {

        if [ ${#MANDATORY_DOCKERS[@]} == 0 ]
        then
               echo "no docker image in config"
               return
        fi

        if ! which docker >/dev/null
        then
               alert "docker not installed (fix: apt-get install docker-ce) [ignoring test]"
               return
        fi

	# check containers are running 
	for INSTANCE in ${MANDATORY_DOCKERS[@]}
	do
		echo checking docker $INSTANCE running
		if [[ $(docker inspect -f '{{.State.Running}}' $INSTANCE 2>/dev/null) != "true" ]]
		then
			alert "container $INSTANCE not running"
		else
			echo checking container $INSTANCE security
			# container is running, check if need upgrade/a rebuilt

			DISTRIBUTION=$(docker container exec $INSTANCE /bin/sh -c 'grep ^ID= /etc/os-release' | cut -d "=" -f 2)

			case $DISTRIBUTION in

				debian)
					echo "$INSTANCE is a debian"

					docker container exec $INSTANCE /bin/sh -c 'apt-get update >/dev/null 2>/dev/null; apt-get upgrade -s; apt-get clean; rm -rf /var/lib/apt/lists/*' >"/tmp/container-$INSTANCE.package-upgrade"
					if grep -i security "/tmp/container-$INSTANCE.package-upgrade"
					then
						alert "container $INSTANCE need security upgrade (or a rebuild)"
					fi

					rm -f "/tmp/container-$INSTANCE.package-upgrade"

					;;
				alpine)
					echo "$INSTANCE is an alpine (case not implemented)"
					;;
				*)
					alert "$INSTANCE is an unknown distribution ($DISTRIBUTION)"
					;;
			esac


		fi
	done
}

check_last_backup() {
	# FIXME: must do it
	true
}



check_mount_points() {

	#FIXME must be dynamic
	# check data mounted
	for DATA in ${PARTITIONS[@]}
	do
		# follow link if necessary
		if [ -L $DATA ] 
		then
			TARGET=$(readlink -f $DATA)
			if [ -z "$TARGET" ]
			then
				alert "wrong symlink $DATA"
				continue
			fi
			DATA=$TARGET
		fi

		mountpoint -q $DATA || alert "$DATA not mounted"
	done

}

check_file_exists() {

	for FILE in ${MANDATORY_FILES[@]}
	do
		echo check that $FILE exists
		[ -e $FILE ] || alert "$FILE does not exist, please check"

	done
}

check_need_reboot() {
	if [ \( -f "/var/run/reboot-required" \) -o \( -f "/var/run/reboot-required.pkgs" \) ]
	then
		alert "system need a reboot"
	fi
}

# ---------------------------------------- commands

cmd_full_check() {

	test -e $REPORT && mv $REPORT $REPORT.prev

	# execute all check_* functions
	for CHECK in $(compgen -A function | grep ^check_ | sort)
	do
		$CHECK
	done

	if [ "$ALARM" != "0" ] 
	then
		notify "please check $HOSTNAME, last error: $(tail -n 1 $REPORT)"
	else
		logger -s -p user.info -t $SCRIPTNAME -- "full check sucess"
		echo "$SCRIPTNAME full-check success at "$(date) >>$REPORT

		if [ -f $REPORT.prev ]
		then
			if ! ( tail -n 1 $REPORT.prev | grep -q "full-check success" )
			then
				# previous test was a failure, notify that everthing is back to normal
				notify "$HOSTNAME full-check is now successful"
			fi
		fi

	fi

}

cmd_install_packages() {

	if [ ${#MANDATORY_PACKAGES[@]} == 0 ]
        then
               echo "no mandatory package in config"
               return 1
        fi

        if ! which apt-get >/dev/null
        then
               echo "apt-get not found, I only know debian systems [ignoring command]"
               return 1
        fi

	apt-get install "${MANDATORY_PACKAGES[@]}"
}

cmd_notify_alive() {
	notify "${HOSTNAME} is alive"
}

cmd_notify_boot() {
	notify "${HOSTNAME} just boot, please check it"
}

cmd_notify() {
	notify "${HOSTNAME}: $*"
}

cmd_last_report() {
	echo
	if [ -e $REPORT ]
	then
		cat $REPORT
	else
		echo "please run '$SCRIPTNAME full-check' to have report"
	fi
	echo
}

cmd_help() {
	cat <<EOF
usage $SCRIPTNAME [options] <command>

options:
	-c|--config <file>	specify config file (default: $CONFIG)
	-r|--report <file>	specify report file (default: $REPORT)
	-s|--silent		mute notifications

command:

	full-check		perform a full host check (use it in cron for periodic check)
	install-packages	install mandatory packages
	last-report		print last report (ex: use in in /etc/update-motd.d)
	notify-alive		notify host is alive (ex: use it in cron for periodic notification)
	notify-boot		notify host just boot (ex: put it in /etc/rc.local)
	notify <message>	send a custom notification
	help 			this help

EOF
}


# ------------------------------------------------------ main

if [ "$UID" != "0" ] 
then 
	echo "must be runned has root"
	exit 1
fi

#lock
exec 100>$LOCK || exit 1
flock -n 100 || exit 1

# will clean up lock at exit
trap end EXIT


# read parameters
while [ $# -gt 0 ]
do
	case $1 in
		-c|--config)
			shift
			CONFIG=$1
			echo CONFIG=$CONFIG;
			shift
			;;

		-r|--report)
			shift
			REPORT=$1
			echo REPORT=$CONFIG;
			shift
			;;

		-s|--silent)
			shift
			NOTIFY=0
			;;

		*)
			# no more parameter
			[ $CONFIG_LOADED -eq 0 ] && load_config

			# check if $1 is a command (prepend cmd_ and replace - by _)
			COMMAND=cmd_${1//[-]/_}
			if ( declare -F "$COMMAND" >/dev/null)
			then
				COMMAND_FOUND=1
				# command exists, execute it giving next parameters
				shift
				$COMMAND "$@"
			fi

			# end loop
			break
	esac
done

if [ $COMMAND_FOUND -eq 0 ]
then
	echo "bad syntax"
	cmd_help
	exit 1
fi

exit $ALARM

