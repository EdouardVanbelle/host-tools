#!/bin/bash

# --------------------------- default config

# setup it into /etc/host-tools/check-health.conf

DISKLIMIT=75
BADSECTORLIMIT=0

DOCKER=()
PARTITIONS=()
EXISTS=()
ROOT_KEYS=()
WEBHOOK=""

# ----------------------------------------


CONFIG="/etc/host-tools/check-health.conf"
REPORT="/var/run/check-health.report"
LOCK="/var/run/check-health.lock"

ALARM=0

# keep original language to normalize script output
LANG=c

alert() {
	ALARM=1
	logger -s -p user.crit -t check-health -- check-health "$@"
	echo "$@" >>$REPORT
}

load_config() {

	echo loading configuration

	if ! [ -e $CONFIG ]
	then
		alert "configuration $CONFIG not found"
		exit 1
	fi

	# load config
	source $CONFIG

}

check_root_sshkeys() {

	local AUTHORIZED_KEY="/root/.ssh/authorized_keys2"

	PREV_IFS=$IFS
	IFS="" 
	for KEY in ${ROOT_KEYS[@]}
	do
		local SHORTKEY=$(echo "$KEY" | awk '{ print $1 " ... " $NF }')
		echo "ensure that $SHORTKEY is present for root"
		if ! ( grep -q ^$KEY $AUTHORIZED_KEY )
		then
			alert "$SHORTKEY is missing in $AUTHORIZED_KEY"
		fi
	done
	IFS=$PREV_IFS
}

check_no_root_password() {
	# because I prefer keys

	echo "checking no root password"

	local ROOT_PASS=$(getent shadow root | cut -d : -f 2)
	[ "$ROOT_PASS" != "*" ] && alert "this machine has a root password, please use ssh key"
}

check_security_upgrade() {

	echo checking security package to upgrade

	apt-get update >/tmp/security-update.list 2>&1
	if grep -q '^[WE]:' /tmp/security-update.list 
	then
		alarm "got warning in apt-get update"
		cat /tmp/security-update.list
	fi

	apt-get upgrade -s >/tmp/security-upgrade.list 2>&1
	if grep -i security /tmp/security-upgrade.list 
	then
		grep -i security /tmp/security-upgrade.list
		alert "system has security packages to upgrade"
	fi

	apt-get clean >/dev/null 2>/dev/null
	#apt-get auto-clean

	rm -f /tmp/security-upgrade.list
	rm -f /tmp/security-update.list
}

check_services() {

	echo "checking systemd services status"

	# example of output
	# networking.service loaded    failed failed Raise network interfaces
	# ureadahead.service not-found failed failed ureadahead.service
	while read -r SERVICE LOAD ACTIVE SUB DESCRIPTION
	do
		alert "service $SERVICE warning (loaded=$LOAD active=$ACTIVE sub=$SUB)"

	done < <( systemctl --state=failed  --no-pager --no-legend )
}

check_disk_sectors() {

	# foreach disk
	for DISK in $( readlink -f /dev/disk/by-id/* | grep -e '[a-z]$' | sort | uniq )
	do

		echo "checking disk $DISK"

		# foreach smartctl

		# smartctl 6.6 2017-11-05 r4594 [x86_64-linux-4.19.0-8-amd64] (local build)
		# Copyright (C) 2002-17, Bruce Allen, Christian Franke, www.smartmontools.org
		#
		# === START OF READ SMART DATA SECTION ===
		# SMART Attributes Data Structure revision number: 16
		# Vendor Specific SMART Attributes with Thresholds:
		# ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE
		#   1 Raw_Read_Error_Rate     0x000b   100   100   016    Pre-fail  Always       -       0
		#   2 Throughput_Performance  0x0005   136   136   054    Pre-fail  Offline      -       80
		#   3 Spin_Up_Time            0x0007   193   193   024    Pre-fail  Always       -       248 (Average 399)
		#   4 Start_Stop_Count        0x0012   100   100   000    Old_age   Always       -       16
		#   5 Reallocated_Sector_Ct   0x0033   100   100   005    Pre-fail  Always       -       0
		#   7 Seek_Error_Rate         0x000b   100   100   067    Pre-fail  Always       -       0
		#   8 Seek_Time_Performance   0x0005   145   145   020    Pre-fail  Offline      -       24
		#   9 Power_On_Hours          0x0012   095   095   000    Old_age   Always       -       39172
		#  10 Spin_Retry_Count        0x0013   100   100   060    Pre-fail  Always       -       0
		#  12 Power_Cycle_Count       0x0032   100   100   000    Old_age   Always       -       16
		# 192 Power-Off_Retract_Count 0x0032   100   100   000    Old_age   Always       -       16
		# 193 Load_Cycle_Count        0x0012   100   100   000    Old_age   Always       -       16
		# 194 Temperature_Celsius     0x0002   166   166   000    Old_age   Always       -       36 (Min/Max 18/49)
		# 196 Reallocated_Event_Count 0x0032   100   100   000    Old_age   Always       -       0
		# 197 Current_Pending_Sector  0x0022   100   100   000    Old_age   Always       -       0
		# 198 Offline_Uncorrectable   0x0008   100   100   000    Old_age   Offline      -       0
		# 199 UDMA_CRC_Error_Count    0x000a   200   200   000    Old_age   Always       -       0

		while read -r ID ATTRIBUTE_NAME FLAG VALUE WORST THRESH TYPE UPDATED WHEN_FAILED RAW_VALUE
		do
			[ -z "$ATTRIBUTE_NAME" ] && continue
			[ -z "$RAW_VALUE" ] && continue

			# debug echo "$DISK $ATTRIBUTE_NAME $RAW_VALUE" 

			case "$ATTRIBUTE_NAME" in 
				"Reallocated_Sector_Ct")
					[ $RAW_VALUE -gt $BADSECTORLIMIT ] && alert "$DISK has $RAW_VALUE bad sectors";
					;;
				"Current_Pending_Sector")
					[ $RAW_VALUE -gt $BADSECTORLIMIT ] && alert "$DISK has $RAW_VALUE coming bad sectors";
					;;
			esac

		done < <( smartctl -A $DISK 2>/dev/null )
	done
}

check_partition_space() {

	while read -r PARTITION FSTYPE IPCENT PCENT
	do
		IPCENT=${IPCENT%?}
		PCENT=${PCENT%?}

		echo checking partition $PARTITION

		if [ $PCENT -ge $DISKLIMIT ]
		then
			alert "$PARTITION reached size limit: $PCENT %"
		fi

		[ -z "$IPCENT" ] && continue

		if [ $IPCENT -ge $DISKLIMIT ]
		then
			alert "$PARTITION reached inode size limit: $IPCENT %"
		fi

	done < <( df -l --exclude-type="devtmpfs" --exclude-type="tmpfs" --output="source,fstype,ipcent,pcent" | tail -n +2 )
}

check_docker() {
	# check containers are running 
	for INSTANCE in ${DOCKER[@]}
	do
		echo checking docker $INSTANCE running
		if [[ $(docker inspect -f '{{.State.Running}}' $INSTANCE 2>/dev/null) != "true" ]]
		then
			alert "container $INSTANCE not running"
		else
			echo checking container $INSTANCE security
			# container is running, check if need upgrade/a rebuilt

			DISTRIBUTION=$(docker container exec $INSTANCE /bin/sh -c 'grep ^ID= /etc/os-release' | cut -d "=" -f 2)

			case $DISTRIBUTION in

				debian)
					echo "$INSTANCE is a debian"

					docker container exec $INSTANCE /bin/sh -c 'apt-get update >/dev/null 2>/dev/null; apt-get upgrade -s; apt-get clean; rm -rf /var/lib/apt/lists/*' >"/tmp/container-$INSTANCE.package-upgrade"
					if grep -i security "/tmp/container-$INSTANCE.package-upgrade"
					then
						alert "container $INSTANCE need security upgrade (or a rebuild)"
					fi

					rm -f "/tmp/container-$INSTANCE.package-upgrade"

					;;
				alpine)
					echo "$INSTANCE is an alpine (case not implemented)"
					;;
				*)
					alert "$INSTANCE is an unknown distribution ($DISTRIBUTION)"
					;;
			esac


		fi
	done
}

check_last_backup() {
	# TODO
	true
}

check_mount_points() {

	#FIXME must be dynamic
	# check data mounted
	for DATA in ${PARTITIONS[@]}
	do
		# follow link if necessary
		if [ -L $DATA ] 
		then
			TARGET=$(readlink -f $DATA)
			if [ -z "$TARGET" ]
			then
				alert "wrong symlink $DATA"
				continue
			fi
			DATA=$TARGET
		fi

		mountpoint -q $DATA || alert "$DATA not mounted"
	done

}

check_file_exists() {

	for FILE in ${EXISTS[@]}
	do
		echo check that $FILE exists
		[ -e $FILE ] || alert "$FILE does not exist, please check"

	done
}

# -----------------------------------------------------------------------------------------------


cd /

HOSTNAME=$(hostname)

#lock
exec 100>$LOCK || exit 1
flock -n 100 || exit 1

load_config

rm -f $REPORT
check_no_root_password
check_root_sshkeys
check_security_upgrade
check_services
check_partition_space
check_disk_sectors
check_docker
check_last_backup
check_mount_points
check_file_exists

if [ x"$ALARM" != x"0" ]
then
	[ -n "$WEBHOOK" ] && curl -s -q ${WEBHOOK}${HOSTNAME}'%20must%20be%20checked' >/dev/null
	exit 1
fi

logger -s -p user.info -t check-health -- "check sucessful"
echo "check-health success at "$(date) >>$REPORT

rm -f $LOCK

exit 0


